<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coin Pixel Blast - Webflow</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    .coin-blast-container {
      position: relative;
      width: 100vw;
      height: 800px;
      overflow: hidden;
    }

    .coin-blast-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
      display: block;
    }
  </style>
</head>
<body>

  <!-- ===== ПРИМЕР ИСПОЛЬЗОВАНИЯ ===== -->
  <div class="coin-blast-container" id="coinBlastContainer">
    <!-- Canvas будет создан автоматически -->
  </div>
  <!-- ===== КОНЕЦ ПРИМЕРА ===== -->

  <!-- Three.js из CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- GLTFLoader из CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    (function() {
      'use strict';

      const MAX_CLICKS = 10;
      const SHAPE_MAP = { square: 0, circle: 1, triangle: 2, diamond: 3 };

      // PixelBlast vertex shader
      const pixelBlastVertexShader = `
        void main() {
          gl_Position = vec4(position, 1.0);
        }
      `;

      // PixelBlast fragment shader
      const pixelBlastFragmentShader = `
        precision highp float;

        uniform vec3  uColor;
        uniform vec2  uResolution;
        uniform float uTime;
        uniform float uPixelSize;
        uniform float uScale;
        uniform float uDensity;
        uniform float uPixelJitter;
        uniform int   uEnableRipples;
        uniform float uRippleSpeed;
        uniform float uRippleThickness;
        uniform float uRippleIntensity;
        uniform float uEdgeFade;
        uniform vec3 uSpotlightPos;
        uniform vec3 uSpotlightTarget;
        uniform float uSpotlightAngle;
        uniform float uSpotlightPenumbra;

        uniform int   uShapeType;
        const int SHAPE_SQUARE   = 0;
        const int SHAPE_CIRCLE   = 1;
        const int SHAPE_TRIANGLE = 2;
        const int SHAPE_DIAMOND  = 3;

        const int   MAX_CLICKS = 10;

        uniform vec2  uClickPos  [MAX_CLICKS];
        uniform float uClickTimes[MAX_CLICKS];

        float Bayer2(vec2 a) {
          a = floor(a);
          return fract(a.x / 2. + a.y * a.y * .75);
        }
        #define Bayer4(a) (Bayer2(.5*(a))*0.25 + Bayer2(a))
        #define Bayer8(a) (Bayer4(.5*(a))*0.25 + Bayer2(a))

        #define FBM_OCTAVES     5
        #define FBM_LACUNARITY  1.25
        #define FBM_GAIN        1.0

        float hash11(float n){ return fract(sin(n)*43758.5453); }

        float vnoise(vec3 p){
          vec3 ip = floor(p);
          vec3 fp = fract(p);
          float n000 = hash11(dot(ip + vec3(0.0,0.0,0.0), vec3(1.0,57.0,113.0)));
          float n100 = hash11(dot(ip + vec3(1.0,0.0,0.0), vec3(1.0,57.0,113.0)));
          float n010 = hash11(dot(ip + vec3(0.0,1.0,0.0), vec3(1.0,57.0,113.0)));
          float n110 = hash11(dot(ip + vec3(1.0,1.0,0.0), vec3(1.0,57.0,113.0)));
          float n001 = hash11(dot(ip + vec3(0.0,0.0,1.0), vec3(1.0,57.0,113.0)));
          float n101 = hash11(dot(ip + vec3(1.0,0.0,1.0), vec3(1.0,57.0,113.0)));
          float n011 = hash11(dot(ip + vec3(0.0,1.0,1.0), vec3(1.0,57.0,113.0)));
          float n111 = hash11(dot(ip + vec3(1.0,1.0,1.0), vec3(1.0,57.0,113.0)));
          vec3 w = fp*fp*fp*(fp*(fp*6.0-15.0)+10.0);
          float x00 = mix(n000, n100, w.x);
          float x10 = mix(n010, n110, w.x);
          float x01 = mix(n001, n101, w.x);
          float x11 = mix(n011, n111, w.x);
          float y0  = mix(x00, x10, w.y);
          float y1  = mix(x01, x11, w.y);
          return mix(y0, y1, w.z) * 2.0 - 1.0;
        }

        float fbm2(vec2 uv, float t){
          vec3 p = vec3(uv * uScale, t);
          float amp = 1.0;
          float freq = 1.0;
          float sum = 1.0;
          for (int i = 0; i < FBM_OCTAVES; ++i){
            sum  += amp * vnoise(p * freq);
            freq *= FBM_LACUNARITY;
            amp  *= FBM_GAIN;
          }
          return sum * 0.5 + 0.5;
        }

        float maskCircle(vec2 p, float cov){
          float r = sqrt(cov) * .25;
          float d = length(p - 0.5) - r;
          float aa = 0.5 * fwidth(d);
          return cov * (1.0 - smoothstep(-aa, aa, d * 2.0));
        }

        float maskTriangle(vec2 p, vec2 id, float cov){
          bool flip = mod(id.x + id.y, 2.0) > 0.5;
          if (flip) p.x = 1.0 - p.x;
          float r = sqrt(cov);
          float d  = p.y - r*(1.0 - p.x);
          float aa = fwidth(d);
          return cov * clamp(0.5 - d/aa, 0.0, 1.0);
        }

        float maskDiamond(vec2 p, float cov){
          float r = sqrt(cov) * 0.564;
          return step(abs(p.x - 0.49) + abs(p.y - 0.49), r);
        }

        void main(){
          float pixelSize = uPixelSize;
          vec2 fragCoord = gl_FragCoord.xy - uResolution * .5;
          float aspectRatio = uResolution.x / uResolution.y;

          vec2 pixelId = floor(fragCoord / pixelSize);
          vec2 pixelUV = fract(fragCoord / pixelSize);

          float cellPixelSize = 8.0 * pixelSize;
          vec2 cellId = floor(fragCoord / cellPixelSize);
          vec2 cellCoord = cellId * cellPixelSize;
          vec2 uv = cellCoord / uResolution;
          uv.x *= aspectRatio;

          float base = fbm2(uv, uTime * 0.05);
          base = base * 0.5 - 0.65;

          float feed = base + (uDensity - 0.5) * 0.3;

          float speed     = uRippleSpeed;
          float thickness = uRippleThickness;
          const float dampT     = 1.0;
          const float dampR     = 10.0;

          if (uEnableRipples == 1) {
            for (int i = 0; i < MAX_CLICKS; ++i){
              vec2 pos = uClickPos[i];
              if (pos.x < 0.0) continue;
              float cellPixelSize = 8.0 * pixelSize;
              vec2 cuv = (pos - uResolution * .5 - cellPixelSize * .5) / uResolution;
              cuv.x *= aspectRatio;
              float t = max(uTime - uClickTimes[i], 0.0);
              float r = distance(uv, cuv);
              float waveR = speed * t;
              float ring  = exp(-pow((r - waveR) / thickness, 2.0));
              float atten = exp(-dampT * t) * exp(-dampR * r);
              feed = max(feed, ring * atten * uRippleIntensity);
            }
          }

          float bayer = Bayer8(fragCoord / uPixelSize) - 0.5;
          float bw = step(0.5, feed + bayer);

          float h = fract(sin(dot(floor(fragCoord / uPixelSize), vec2(127.1, 311.7))) * 43758.5453);
          float jitterScale = 1.0 + (h - 0.5) * uPixelJitter;
          float coverage = bw * jitterScale;
          float M;
          if      (uShapeType == SHAPE_CIRCLE)   M = maskCircle (pixelUV, coverage);
          else if (uShapeType == SHAPE_TRIANGLE) M = maskTriangle(pixelUV, pixelId, coverage);
          else if (uShapeType == SHAPE_DIAMOND)  M = maskDiamond(pixelUV, coverage);
          else                                   M = coverage;

          if (uEdgeFade > 0.0) {
            vec2 norm = gl_FragCoord.xy / uResolution;
            float edge = min(min(norm.x, norm.y), min(1.0 - norm.x, 1.0 - norm.y));
            float fade = smoothstep(0.0, uEdgeFade, edge);
            M *= fade;
          }

          vec2 screenPos = (gl_FragCoord.xy / uResolution) * 2.0 - 1.0;
          float aspectRatio2 = uResolution.x / uResolution.y;
          screenPos.x *= aspectRatio2;
          vec3 worldPos = vec3(screenPos * 1.0, 0.0);

          vec3 spotDir = normalize(uSpotlightTarget - uSpotlightPos);
          vec3 lightToFrag = worldPos - uSpotlightPos;

          float t = -uSpotlightPos.z / spotDir.z;
          vec3 spotCenterOnPlane = uSpotlightPos + spotDir * t;

          float distFromCenter = length(worldPos.xy - spotCenterOnPlane.xy);

          float spotRadius = abs(t) * tan(uSpotlightAngle);
          float spotOuterRadius = abs(t) * tan(uSpotlightAngle + uSpotlightPenumbra);

          float spotMask = 1.0 - smoothstep(spotRadius, spotOuterRadius, distFromCenter);

          M *= (1.0 - spotMask * 0.98);

          vec3 color = uColor;

          vec3 srgbColor = mix(
            color * 12.92,
            1.055 * pow(color, vec3(1.0 / 2.4)) - 0.055,
            step(0.0031308, color)
          );

          gl_FragColor = vec4(srgbColor, M);
        }
      `;

      // Coin vertex shader
      const coinVertexShader = `
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        varying vec2 vUv;

        void main() {
          vUv = uv;
          vNormal = normalize(normalMatrix * normal);
          vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;

      // Coin fragment shader
      const coinFragmentShader = `
        precision mediump float;

        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        varying vec2 vUv;

        uniform vec3 u_lightPosition;
        uniform vec3 u_lightColor;
        uniform float u_lightIntensity;
        uniform vec3 u_ambientLight;
        uniform vec2 u_resolution;
        uniform float u_pxSize;
        uniform vec4 u_colorBack;
        uniform vec4 u_colorFront;
        uniform float u_roughness;
        uniform vec3 u_spotlightPos;
        uniform vec3 u_spotlightTarget;
        uniform float u_spotlightAngle;
        uniform float u_spotlightPenumbra;

        const int bayer8x8[64] = int[64](
          0, 32, 8, 40, 2, 34, 10, 42,
          48, 16, 56, 24, 50, 18, 58, 26,
          12, 44, 4, 36, 14, 46, 6, 38,
          60, 28, 52, 20, 62, 30, 54, 22,
          3, 35, 11, 43, 1, 33, 9, 41,
          51, 19, 59, 27, 49, 17, 57, 25,
          15, 47, 7, 39, 13, 45, 5, 37,
          63, 31, 55, 23, 61, 29, 53, 21
        );

        float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        float noise(vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);

          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));

          vec2 u = f * f * (3.0 - 2.0 * f);

          return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        float getBayerValue(vec2 uv, int size) {
          ivec2 pos = ivec2(fract(uv / float(size)) * float(size));
          int index = pos.y * size + pos.x;
          return float(bayer8x8[index]) / 64.0;
        }

        void main() {
          vec3 normal = normalize(vNormal);
          vec3 lightDir = normalize(u_lightPosition - vPosition);

          vec2 roughnessUV = vUv * 80.0;
          float roughnessNoise = noise(roughnessUV) * u_roughness;

          normal.x += roughnessNoise * 0.15;
          normal.y += roughnessNoise * 0.15;
          normal = normalize(normal);

          float diff = max(dot(normal, lightDir), 0.0);

          float lightValue = u_ambientLight.r + (u_lightIntensity * diff);

          vec3 spotDir = normalize(u_spotlightTarget - u_spotlightPos);
          vec3 lightToFrag = normalize(vWorldPosition - u_spotlightPos);
          float spotAngle = dot(spotDir, lightToFrag);
          float spotCutoff = cos(u_spotlightAngle);
          float spotOuterCutoff = cos(u_spotlightAngle + u_spotlightPenumbra);
          float spotMask = smoothstep(spotOuterCutoff, spotCutoff, spotAngle);

          float pxSize = u_pxSize;
          vec2 pxSizeUV = gl_FragCoord.xy - 0.5 * u_resolution;
          pxSizeUV /= pxSize;

          float dithering = getBayerValue(pxSizeUV, 8);
          dithering -= 1.2;

          float shadowFactor = 1.0 - spotMask;
          float ditheringMultiplier = 0.15 + shadowFactor * 1.2;
          float adjustedDithering = dithering * ditheringMultiplier;

          float res = step(0.5, lightValue + adjustedDithering);

          vec3 fgColor = u_colorFront.rgb * u_colorFront.a;
          float fgOpacity = u_colorFront.a;
          vec3 bgColor = u_colorBack.rgb * u_colorBack.a;
          float bgOpacity = u_colorBack.a;

          vec3 color = fgColor * res;
          float opacity = fgOpacity * res;

          color += bgColor * (1.0 - opacity);
          opacity += bgOpacity * (1.0 - opacity);

          float luminance = dot(color, vec3(0.299, 0.587, 0.114));
          if (luminance < 0.08) {
            color = vec3(0.0);
          }

          gl_FragColor = vec4(color, opacity);
        }
      `;

      class CoinPixelBlastEffect {
        constructor(container, options) {
          this.container = container;
          this.disposed = false;

          // Configuration
          this.config = {
            variant: 'square',
            pixelSize: 4,
            color: '#ffffff',
            patternScale: 3,
            patternDensity: 1,
            pixelSizeJitter: 0,
            enableRipples: true,
            rippleIntensityScale: 1,
            rippleThickness: 0.1,
            rippleSpeed: 0.4,
            speed: 0.2,
            edgeFade: 0,
            modelUrl: '/eth-coin.glb.txt',
            ...options
          };

          // Get container dimensions
          this.width = this.container.clientWidth;
          this.height = this.container.clientHeight;

          this.init();
        }

        init() {
          // Create scene
          this.scene = new THREE.Scene();

          // Create camera
          const aspect = this.width / this.height;
          const frustumSize = 2;
          this.camera = new THREE.OrthographicCamera(
            -frustumSize * aspect / 2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            -frustumSize / 2,
            0.1,
            100
          );
          this.camera.position.z = 5;

          // Create renderer
          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            logarithmicDepthBuffer: true
          });
          this.renderer.setSize(this.width, this.height);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          this.renderer.setClearColor(0x000000, 1);
          this.renderer.domElement.classList.add('coin-blast-canvas');
          this.container.appendChild(this.renderer.domElement);

          // Create background
          this.createPixelBlastBackground();

          // Load coin
          this.loadCoin();

          // Create lights
          this.createLights();

          // Animation
          this.clock = new THREE.Clock();
          this.clickIndex = 0;
          this.animate();

          // Mouse interaction
          this.setupMouseInteraction();

          // Resize handler
          this.boundOnResize = () => this.onResize();
          window.addEventListener('resize', this.boundOnResize);
        }

        createPixelBlastBackground() {
          const geometry = new THREE.PlaneGeometry(2, 2);

          const clickPositions = [];
          const clickTimes = [];
          for (let i = 0; i < MAX_CLICKS; i++) {
            clickPositions.push(new THREE.Vector2(-1, -1));
            clickTimes.push(0);
          }

          const uniforms = {
            uResolution: { value: new THREE.Vector2(
              this.renderer.domElement.width,
              this.renderer.domElement.height
            )},
            uTime: { value: 0 },
            uColor: { value: new THREE.Color(this.config.color) },
            uClickPos: { value: clickPositions },
            uClickTimes: { value: new Float32Array(clickTimes) },
            uShapeType: { value: SHAPE_MAP[this.config.variant] ?? 0 },
            uPixelSize: { value: this.config.pixelSize * this.renderer.getPixelRatio() },
            uScale: { value: this.config.patternScale },
            uDensity: { value: this.config.patternDensity },
            uPixelJitter: { value: this.config.pixelSizeJitter },
            uEnableRipples: { value: this.config.enableRipples ? 1 : 0 },
            uRippleSpeed: { value: this.config.rippleSpeed },
            uRippleThickness: { value: this.config.rippleThickness },
            uRippleIntensity: { value: this.config.rippleIntensityScale },
            uEdgeFade: { value: this.config.edgeFade },
            uSpotlightPos: { value: new THREE.Vector3() },
            uSpotlightTarget: { value: new THREE.Vector3() },
            uSpotlightAngle: { value: Math.PI / 6 },
            uSpotlightPenumbra: { value: 0.4 }
          };

          this.bgMaterial = new THREE.ShaderMaterial({
            vertexShader: pixelBlastVertexShader,
            fragmentShader: pixelBlastFragmentShader,
            uniforms: uniforms,
            transparent: true,
            depthTest: true,
            depthWrite: true,
            side: THREE.DoubleSide
          });

          this.bgQuad = new THREE.Mesh(geometry, this.bgMaterial);
          this.bgQuad.frustumCulled = false;
          this.bgQuad.renderOrder = -1;
          this.bgQuad.position.z = 0;

          this.scene.add(this.bgQuad);
        }

        createLights() {
          // Spotlight
          this.spotLight = new THREE.SpotLight(0xffffff, 8);
          this.spotLight.position.set(0.66, -0.66, -1);
          this.spotLight.target.position.set(0.5, -2, 3);
          this.scene.add(this.spotLight.target);
          this.spotLight.angle = Math.PI / 60;
          this.spotLight.penumbra = 0.5;
          this.spotLight.decay = 10;
          this.spotLight.distance = 10;
          this.spotLight.castShadow = false;
          this.scene.add(this.spotLight);

          // Ambient light
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          this.scene.add(ambientLight);

          // Directional light
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(0, 4, 2);
          directionalLight.castShadow = false;
          this.scene.add(directionalLight);
        }

        loadCoin() {
          const loader = new THREE.GLTFLoader();

          loader.load(
            this.config.modelUrl,
            (gltf) => {
              this.coin = gltf.scene;

              const box = new THREE.Box3().setFromObject(gltf.scene);
              const center = box.getCenter(new THREE.Vector3());
              const size = box.getSize(new THREE.Vector3());

              gltf.scene.position.sub(center);

              const maxDim = Math.max(size.x, size.y, size.z);
              const targetSize = 1.5;
              const scale = targetSize / maxDim;
              gltf.scene.scale.setScalar(scale);

              gltf.scene.position.set(0.66, -0.66, 3);

              gltf.scene.rotation.x = Math.PI * 1.35;
              gltf.scene.rotation.y = Math.PI * 1.1;
              gltf.scene.rotation.z = Math.PI * 0.2;

              gltf.scene.traverse((child) => {
                if (child.isMesh) {
                  child.material = new THREE.ShaderMaterial({
                    vertexShader: coinVertexShader,
                    fragmentShader: coinFragmentShader,
                    uniforms: {
                      u_lightPosition: { value: new THREE.Vector3(-1, 3, 5) },
                      u_lightColor: { value: new THREE.Color(0xffffff) },
                      u_lightIntensity: { value: 0.43 },
                      u_ambientLight: { value: new THREE.Color(0.4, 0.4, 0.4) },
                      u_resolution: { value: new THREE.Vector2(this.width, this.height) },
                      u_pxSize: { value: 6 },
                      u_colorBack: { value: new THREE.Vector4(0.0, 0.0, 0.0, 1.0) },
                      u_colorFront: { value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0) },
                      u_roughness: { value: 0.4 },
                      u_spotlightPos: { value: new THREE.Vector3() },
                      u_spotlightTarget: { value: new THREE.Vector3() },
                      u_spotlightAngle: { value: Math.PI / 8 },
                      u_spotlightPenumbra: { value: 0.4 }
                    },
                    side: THREE.DoubleSide,
                    transparent: true
                  });
                  child.castShadow = false;
                  child.receiveShadow = false;
                }
              });

              this.scene.add(gltf.scene);
              console.log('Coin loaded');
            },
            (progress) => {
              console.log(`Loading: ${Math.round(progress.loaded / progress.total * 100)}%`);
            },
            (error) => {
              console.error('Error loading coin:', error);
            }
          );
        }

        setupMouseInteraction() {
          const canvas = this.renderer.domElement;

          canvas.addEventListener('pointerdown', (e) => {
            const rect = canvas.getBoundingClientRect();

            const nx = (e.clientX - rect.left) / rect.width;
            const ny = 1.0 - (e.clientY - rect.top) / rect.height;

            const fx = nx * canvas.width;
            const fy = ny * canvas.height;

            const uniforms = this.bgMaterial.uniforms;
            uniforms.uClickPos.value[this.clickIndex].set(fx, fy);
            uniforms.uClickTimes.value[this.clickIndex] = uniforms.uTime.value;
            this.clickIndex = (this.clickIndex + 1) % MAX_CLICKS;
          });
        }

        onResize() {
          if (this.disposed) return;

          const width = this.container.clientWidth || this.width;
          const height = this.container.clientHeight || this.height;

          const aspect = width / height;
          const frustumSize = 2;
          this.camera.left = -frustumSize * aspect / 2;
          this.camera.right = frustumSize * aspect / 2;
          this.camera.top = frustumSize / 2;
          this.camera.bottom = -frustumSize / 2;
          this.camera.updateProjectionMatrix();

          this.renderer.setSize(width, height);

          if (this.bgQuad) {
            this.bgQuad.geometry.dispose();
            this.bgQuad.geometry = new THREE.PlaneGeometry(2, 2);
          }

          const uniforms = this.bgMaterial.uniforms;
          uniforms.uResolution.value.set(
            this.renderer.domElement.width,
            this.renderer.domElement.height
          );
          uniforms.uPixelSize.value = this.config.pixelSize * this.renderer.getPixelRatio();

          if (this.coin) {
            this.coin.traverse((child) => {
              if (child.isMesh && child.material.uniforms && child.material.uniforms.u_resolution) {
                child.material.uniforms.u_resolution.value.set(width, height);
              }
            });
          }
        }

        animate() {
          if (this.disposed) return;

          this.animationId = requestAnimationFrame(() => this.animate());

          const elapsed = this.clock.getElapsedTime() * this.config.speed;

          this.bgMaterial.uniforms.uTime.value = elapsed;

          if (this.coin) {
            this.coin.traverse((child) => {
              if (child.isMesh && child.material.uniforms) {
                if (child.material.uniforms.u_spotlightPos && this.spotLight) {
                  child.material.uniforms.u_spotlightPos.value.copy(this.spotLight.position);
                  child.material.uniforms.u_spotlightTarget.value.copy(this.spotLight.target.position);
                  child.material.uniforms.u_spotlightAngle.value = this.spotLight.angle;
                  child.material.uniforms.u_spotlightPenumbra.value = this.spotLight.penumbra;
                }
              }
            });
          }

          if (this.spotLight) {
            this.bgMaterial.uniforms.uSpotlightPos.value.copy(this.spotLight.position);
            this.bgMaterial.uniforms.uSpotlightTarget.value.copy(this.spotLight.target.position);
            this.bgMaterial.uniforms.uSpotlightAngle.value = this.spotLight.angle;
            this.bgMaterial.uniforms.uSpotlightPenumbra.value = this.spotLight.penumbra;
          }

          if (this.coin) {
            const maxRotation = 20 * Math.PI / 180;
            const rotationAngle = Math.sin(elapsed * 1.0) * maxRotation;
            this.coin.rotation.z = rotationAngle;
          }

          this.renderer.render(this.scene, this.camera);
        }

        dispose() {
          this.disposed = true;

          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
          }

          if (this.boundOnResize) {
            window.removeEventListener('resize', this.boundOnResize);
          }

          if (this.bgQuad) {
            this.bgQuad.geometry.dispose();
            this.bgMaterial.dispose();
          }

          if (this.coin) {
            this.coin.traverse((child) => {
              if (child.isMesh) {
                child.geometry.dispose();
                if (child.material) {
                  child.material.dispose();
                }
              }
            });
          }

          if (this.renderer) {
            this.renderer.dispose();
            if (this.renderer.domElement.parentElement === this.container) {
              this.container.removeChild(this.renderer.domElement);
            }
          }

          if (this.scene) this.scene.clear();
        }
      }

      // Auto-initialize
      function initCoinBlastEffects() {
        const containers = document.querySelectorAll('.coin-blast-container');
        containers.forEach(container => {
          new CoinPixelBlastEffect(container);
        });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initCoinBlastEffects);
      } else {
        initCoinBlastEffects();
      }

    })();
  </script>
</body>
</html>
